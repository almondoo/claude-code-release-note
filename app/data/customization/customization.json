{
  "tabs": [
    {
      "id": "skills",
      "name": "スキル",
      "description": "SKILL.md ファイルで Claude Code にカスタムコマンドと独自の振る舞いを追加する",
      "items": [
        {
          "id": "skills-overview",
          "title": "スキルとは",
          "description": "Claude Code に独自の機能を追加する Agent Skills オープン標準。SKILL.md ファイルを配置するだけで /スキル名 として呼び出せる。",
          "content": "スキルは Claude Code に独自のスラッシュコマンドと動作を追加するための仕組みです。Agent Skills オープン標準に準拠しており、SKILL.md ファイルを特定のディレクトリに配置するだけで動作します。\n\nユーザーが /スキル名 と入力するか、Claude が関連するスキルを自動で検出・読み込んで実行します。スキルはプロジェクト固有のワークフロー、チームの作業手順、繰り返し使う指示のテンプレート化に最適です。",
          "code": [
            {
              "lang": "markdown",
              "label": "最小限の SKILL.md（.claude/skills/greet/SKILL.md）",
              "value": "---\nname: greet\ndescription: ユーザーを名前で挨拶する\n---\n\n$ARGUMENTS に含まれる名前を使って、日本語で丁寧に挨拶してください。",
              "recommended": true
            }
          ],
          "callouts": [
            {
              "type": "info",
              "text": "Claude はセッション内で関連するスキルを自動で検出し、コンテキストに応じて読み込みます。ユーザーが明示的に /スキル名 で呼び出すことも可能です。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "skills-placement",
          "title": "スキルの配置場所",
          "description": "4 つのスコープ（Enterprise > Personal > Project > Plugin）で管理。同名スキルは Enterprise が最優先。",
          "content": "スキルは 4 つのスコープで配置でき、優先度は Enterprise > Personal > Project > Plugin の順です。同名スキルが複数存在する場合、より上位のスコープが使われます。\n\nモノレポ環境では、サブディレクトリの .claude/skills/ も自動で検出されます。--add-dir フラグで追加ディレクトリを指定することもできます。\n\n後方互換として .claude/commands/ も引き続き有効です。",
          "code": [
            {
              "lang": "text",
              "label": "スコープ別の配置パス",
              "value": "# Enterprise スコープ（管理ポリシー）\n/Library/Application Support/ClaudeCode/skills/  # macOS\n/etc/claude-code/skills/                        # Linux\n\n# Personal スコープ（全プロジェクト共通）\n~/.claude/skills/<スキル名>/SKILL.md\n\n# Project スコープ（プロジェクト固有）\n.claude/skills/<スキル名>/SKILL.md\n\n# Plugin スコープ（プラグイン経由）\n# プラグインの skills/ ディレクトリ"
            }
          ],
          "callouts": [
            {
              "type": "tip",
              "text": "チーム全体で使うスキルは ~/.claude/skills/ に、プロジェクト固有のものは .claude/skills/ に配置し、.gitignore を使い分けてください。"
            }
          ],
          "tags": ["上級者向け", "チーム向け"]
        },
        {
          "id": "skills-create",
          "title": "SKILL.md の書き方",
          "description": "YAML フロントマター + Markdown 本文の 2 部構成。name は 64 文字以内、description は Claude がトリガー判断に使用。",
          "content": "SKILL.md は YAML フロントマターと Markdown 本文の 2 部構成です。フロントマターには name（省略時はディレクトリ名、64 文字以内、小文字英数字とハイフンのみ）と description（1024 文字以内）を記述します。\n\n本文が Claude への指示内容になります。リファレンス型（知識・規約を提供）とタスク型（手順を実行させる）の 2 パターンがあります。",
          "code": [
            {
              "lang": "markdown",
              "label": "タスク型スキル（.claude/skills/review/SKILL.md）",
              "value": "---\nname: review\ndescription: コードレビューを実行する。git diff の内容を確認し、コーディング規約・セキュリティ・テストカバレッジを評価する\n---\n\n以下の手順でコードレビューを行ってください:\n\n1. `git diff HEAD` で変更内容を確認する\n2. コーディング規約への準拠を確認する\n3. セキュリティ上の問題がないか確認する\n4. テストが十分か確認する\n5. 改善提案をリストアップする",
              "recommended": true
            },
            {
              "lang": "markdown",
              "label": "リファレンス型スキル（~/.claude/skills/team-guide/SKILL.md）",
              "value": "---\nname: team-guide\ndescription: チームのコーディング規約と開発ガイドラインを参照する\nuser-invocable: false\n---\n\n# チーム開発ガイドライン\n\n- コミットメッセージ: Conventional Commits 形式\n- ブランチ名: feature/, fix/, docs/ プレフィックス\n- PR: 必ず 1 名以上のレビュアーを指定する\n- テスト: カバレッジ 80% 以上を維持する"
            }
          ],
          "callouts": [
            {
              "type": "info",
              "text": "description フィールドに具体的なキーワードを含めると、Claude がスキルを自動で検出しやすくなります。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "skills-frontmatter",
          "title": "フロントマター全フィールド",
          "description": "name, description, argument-hint, user-invocable, disable-model-invocation, allowed-tools, model, context, agent, hooks の全 10 フィールドの仕様。",
          "content": "SKILL.md のフロントマターで指定できる全フィールドの一覧です。フィールド名はハイフン区切りです（アンダースコアではありません）。\n\n呼び出し制御の 3 パターン:\n- デフォルト: ユーザーも Claude も呼び出し可能\n- disable-model-invocation: true → ユーザーのみ（デプロイ等の副作用あるスキル向け）\n- user-invocable: false → Claude のみ（バックグラウンド知識向け）",
          "code": [
            {
              "lang": "yaml",
              "label": "全フィールドのリファレンス",
              "value": "---\n# 基本情報\nname: my-skill              # スキル名（64文字以内、小文字英数字+ハイフン）\ndescription: スキルの説明    # Claude のトリガー判断に使用（1024文字以内）\nargument-hint: \"[引数の説明]\" # /スキル名 の引数ヒント\n\n# 呼び出し制御\nuser-invocable: true         # false: Claude のみが呼び出し可能\ndisable-model-invocation: false # true: ユーザーのみが呼び出し可能\n\n# ツール制限\nallowed-tools:               # このスキル内で使用可能なツール\n  - Bash\n  - Read\n  - Edit\n\n# 実行設定\nmodel: claude-sonnet-4-5    # 使用モデル（省略時はセッションのモデル）\ncontext: fork                # fork: サブエージェントとして実行\nagent: Explore               # 使用するエージェントタイプ\n\n# フック（スキル内のライフサイクル）\nhooks: {}                    # スキル固有のフック設定\n---"
            }
          ],
          "callouts": [
            {
              "type": "important",
              "text": "フィールド名はハイフン区切り（user-invocable, disable-model-invocation）です。アンダースコアは無効です。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "skills-arguments",
          "title": "引数の受け渡し",
          "description": "$ARGUMENTS プレースホルダーでユーザー入力をスキルに渡す。インデックスアクセスや環境変数も利用可能。",
          "content": "スキルはユーザーからの引数を $ARGUMENTS プレースホルダーで受け取れます。インデックスアクセス（$ARGUMENTS[0] または $1）で個別の引数を参照することもできます。\n\n$ARGUMENTS が本文にない場合、引数は自動的に末尾に追加されます。また、${CLAUDE_SESSION_ID} などのセッション変数も利用できます。",
          "code": [
            {
              "lang": "markdown",
              "label": "複数引数を使うスキル（.claude/skills/migrate/SKILL.md）",
              "value": "---\nname: migrate\ndescription: コンポーネントを移行する。引数: [コンポーネント名] [移行先ディレクトリ]\nargument-hint: \"[component-name] [target-dir]\"\n---\n\n以下のコンポーネントを移行してください:\n- コンポーネント名: $ARGUMENTS[0]\n- 移行先: $ARGUMENTS[1]\n\n手順:\n1. 元のファイルを $ARGUMENTS[1] にコピーする\n2. import パスを更新する\n3. 旧ファイルを削除する\n4. テストを実行して動作確認する",
              "recommended": true
            },
            {
              "lang": "bash",
              "label": "呼び出し例",
              "value": "# セッション内で引数付き呼び出し\n> /migrate Button src/components/ui\n\n# $ARGUMENTS[0] = \"Button\"\n# $ARGUMENTS[1] = \"src/components/ui\""
            }
          ],
          "callouts": [
            {
              "type": "tip",
              "text": "${CLAUDE_SESSION_ID} で現在のセッション ID を取得できます。非同期処理や外部ツールとの連携に活用できます。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "skills-invocation",
          "title": "呼び出し制御",
          "description": "disable-model-invocation でデプロイ等の副作用スキルをユーザー専用に。user-invocable: false で Claude 専用知識に。",
          "content": "スキルの呼び出し元を制御することで、副作用のある操作を安全に管理できます。\n\ndisable-model-invocation: true を設定すると、Claude がそのスキルを自律的に呼び出せなくなります。ユーザーが明示的に /スキル名 と入力した場合のみ実行されます。デプロイやデータベース操作など、慎重を要するスキルに適しています。\n\nuser-invocable: false はその逆で、ユーザーが /スキル名 で呼び出せず、Claude のみが内部的に参照します。バックグラウンド知識やコンテキスト提供に適しています。",
          "code": [
            {
              "lang": "yaml",
              "label": "ユーザー専用スキル（副作用あり）",
              "value": "---\nname: deploy\ndescription: 本番環境にデプロイする\ndisable-model-invocation: true\nallowed-tools:\n  - Bash\n---\n\n本番環境へのデプロイを実行します。\n\n1. `pnpm run build` でビルドを確認\n2. `git push origin main` でコードをプッシュ\n3. デプロイスクリプトを実行: `./scripts/deploy.sh`"
            },
            {
              "lang": "yaml",
              "label": "Claude 専用知識スキル",
              "value": "---\nname: api-conventions\ndescription: このプロジェクトの API 設計規約と命名ルール\nuser-invocable: false\n---\n\n# API 設計規約\n\n- エンドポイントは RESTful 設計に従う\n- レスポンスは { data, error, meta } の構造\n- エラーコードは HTTP ステータスコードと一致させる"
            }
          ],
          "callouts": [
            {
              "type": "warning",
              "text": "disable-model-invocation と user-invocable: false を同時に設定すると、誰も呼び出せなくなります。"
            }
          ],
          "tags": ["上級者向け", "チーム向け"]
        },
        {
          "id": "skills-subagent",
          "title": "サブエージェント実行",
          "description": "context: fork でサブエージェントとして独立実行。agent フィールドで Explore / Plan / general-purpose 等を指定。",
          "content": "context: fork を設定すると、スキルはメインの会話から独立したサブエージェントとして実行されます。会話履歴にアクセスせず、独立したコンテキストで動作します。\n\nagent フィールドで実行エージェントの種類を指定できます: Explore（リサーチ特化）、Plan（設計特化）、general-purpose（汎用）、またはカスタムエージェント名。\n\nmodel フィールドでサブエージェントが使用するモデルを個別に指定することも可能です。",
          "code": [
            {
              "lang": "markdown",
              "label": "Explore エージェントでリサーチするスキル",
              "value": "---\nname: research\ndescription: コードベースをリサーチして依存関係の分析レポートを生成する\ncontext: fork\nagent: Explore\nmodel: claude-haiku-4-5-20251001\n---\n\n以下のコードベース分析を実施してください:\n\n1. package.json の依存関係を確認する\n2. 各主要ライブラリの用途を特定する\n3. セキュリティ上の懸念がある依存関係を検出する\n4. アップデート推奨パッケージをリストアップする\n\n結果をマークダウン形式でまとめてください。",
              "recommended": true
            }
          ],
          "callouts": [
            {
              "type": "info",
              "text": "サブエージェントは独立した会話コンテキストで実行されるため、メインセッションの履歴は参照されません。長時間タスクや重い分析に適しています。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "skills-dynamic",
          "title": "動的コンテキスト注入",
          "description": "!`command` 構文でシェルコマンドの実行結果をスキルに注入。Claude に届く前に前処理として実行される。",
          "content": "SKILL.md 本文内で `` !`command` `` 構文を使うと、スキル呼び出し時にシェルコマンドが実行され、その結果が本文に展開されてから Claude に渡されます。\n\nClaude が受け取るのは展開後のテキストのみです。動的な情報（PR の差分、現在の git 状態、環境情報など）をスキル実行時に自動で取得する際に便利です。",
          "code": [
            {
              "lang": "markdown",
              "label": "PR 情報を動的注入するスキル（.claude/skills/pr-summary/SKILL.md）",
              "value": "---\nname: pr-summary\ndescription: 現在の PR の差分を要約する\n---\n\n以下の PR 差分を日本語で要約し、変更の目的・影響範囲・注意点をまとめてください:\n\n```diff\n!`gh pr diff`\n```\n\n現在のブランチ: !`git branch --show-current`",
              "recommended": true
            }
          ],
          "callouts": [
            {
              "type": "warning",
              "text": "!`command` 構文はシェルで実行されます。信頼できるコマンドのみ使用し、ユーザー入力を直接コマンドに渡さないでください。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "skills-files",
          "title": "サポートファイルの活用",
          "description": "SKILL.md は 500 行以内推奨。詳細なリファレンスは reference.md 等に分離してリンクで参照。",
          "content": "スキルはディレクトリ構造を活用して、メインの SKILL.md と補助ファイルを分けて管理できます。SKILL.md は 500 行以内を推奨し、詳細な仕様や大きなコード例は別ファイルに分離して SKILL.md からリンクで参照します。\n\nスクリプトファイルを scripts/ サブディレクトリに置くことも可能です。",
          "code": [
            {
              "lang": "text",
              "label": "スキルのディレクトリ構成例",
              "value": ".claude/skills/codebase-visualizer/\n├── SKILL.md           # メインファイル（Claude への指示）\n├── reference.md       # 詳細な仕様リファレンス\n├── examples.md        # コード例集\n└── scripts/\n    └── generate.py    # ヘルパースクリプト"
            },
            {
              "lang": "markdown",
              "label": "別ファイルを参照する SKILL.md",
              "value": "---\nname: codebase-visualizer\ndescription: コードベースの依存関係グラフを生成する\n---\n\nコードベースの依存関係を分析して可視化します。\n\n詳細な仕様は [reference.md](reference.md) を参照してください。\nコード例は [examples.md](examples.md) を参照してください。\n\n処理手順:\n1. scripts/generate.py を実行してグラフデータを収集\n2. D3.js 形式の JSON を生成\n3. 結果を依存関係.md として保存"
            }
          ],
          "callouts": [
            {
              "type": "tip",
              "text": "SKILL.md が長くなると Claude のコンテキスト消費が増えます。500 行を超える場合は reference.md 等に分割することを推奨します。"
            }
          ],
          "tags": ["上級者向け", "チーム向け"]
        },
        {
          "id": "skills-bestpractices",
          "title": "ベストプラクティス",
          "description": "description にキーワードを含める。スキルが多い場合のバジェット管理。スキルが発火しない・しすぎる場合の対処法。",
          "content": "スキルを効果的に使うためのベストプラクティスをまとめます。\n\ndescription フィールドには具体的なキーワードを含めると、Claude が自動でスキルを検出・発火させやすくなります。\n\nスキルが多すぎる場合、コンテキストの 2% というバジェット制限があります。/context コマンドで除外されているスキルを確認でき、SLASH_COMMAND_TOOL_CHAR_BUDGET 環境変数で上限を変更できます。",
          "code": [
            {
              "lang": "bash",
              "label": "スキルのデバッグとバジェット確認",
              "value": "# セッション内でコンテキスト使用状況を確認\n> /context\n\n# バジェット上限を変更（デフォルト: コンテキストの 2%）\nexport SLASH_COMMAND_TOOL_CHAR_BUDGET=50000\n\n# スキルが発火しない場合: description を改善する\n# スキルが多すぎる場合: バジェットを増やすか、スキルを整理する"
            }
          ],
          "callouts": [
            {
              "type": "tip",
              "text": "description に「〜する時」「〜が必要な場合」などのトリガーキーワードを含めると、Claude がより正確にスキルを判断できます。"
            }
          ],
          "tags": ["上級者向け"]
        }
      ]
    },
    {
      "id": "mcp",
      "name": "MCP",
      "description": "Model Context Protocol で外部ツール・データソースを Claude Code に接続する",
      "items": [
        {
          "id": "mcp-overview",
          "title": "MCP とは",
          "description": "外部ツール・データソースへの接続標準。GitHub / DB / ブラウザ / Slack 等を Claude Code から自然言語で操作できる。",
          "content": "MCP（Model Context Protocol）は Claude Code に外部ツールやデータソースを接続するためのオープン標準プロトコルです。MCP サーバーを設定すると、Claude Code はそのサーバーが提供するツールを呼び出せます。\n\n主な活用場面:\n- GitHub / GitLab: PR・Issue・コードの操作\n- データベース: SQL クエリを自然言語で実行\n- ブラウザ操作: Web スクレイピング・E2E テスト補助\n- Slack / Notion: チャット・ドキュメント管理の自動化\n- ファイルシステム: 指定ディレクトリ内の安全な操作",
          "code": [
            {
              "lang": "text",
              "label": "MCP のアーキテクチャ",
              "value": "┌──────────────────────────────────┐\n│   Claude Code（クライアント）     │\n│                                  │\n│  「このPRにコメントして」         │\n│  「DBのユーザー数を教えて」       │\n└──────────────┬───────────────────┘\n               │ MCP プロトコル\n               │ (HTTP / SSE / stdio)\n       ┌───────┴────────┐\n       │                │\n       ▼                ▼\n ┌───────────┐    ┌───────────┐\n │  GitHub   │    │ Postgres  │\n │ MCPサーバー│    │ MCPサーバー│\n └─────┬─────┘    └─────┬─────┘\n       │                │\n       ▼                ▼\n  GitHub API      PostgreSQL DB"
            }
          ],
          "callouts": [
            {
              "type": "info",
              "text": "MCP サーバーの公式一覧は github.com/modelcontextprotocol/servers で確認できます。コミュニティ製も含めると数百種類のサーバーが利用可能です。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "mcp-transport",
          "title": "3 つのトランスポート",
          "description": "HTTP（推奨・リモート向け）、SSE（非推奨・レガシー）、stdio（ローカルプロセス向け）の使い分け。",
          "content": "MCP サーバーとの通信方式（トランスポート）は 3 種類あります。\n\nHTTP: 推奨。リモートサーバーへの接続に使用。--header でカスタムヘッダーを追加可能。\nstdio: ローカルプロセスとして起動するサーバーに使用。最もシンプルな方式。\nSSE: 非推奨（レガシー互換）。既存の SSE サーバーとの互換性のために残されています。",
          "code": [
            {
              "lang": "bash",
              "label": "各トランスポートの追加方法",
              "value": "# HTTP（推奨・リモートサーバー）\nclaude mcp add my-remote -s project \\\n  --transport http \\\n  --url https://mcp.example.com/endpoint \\\n  --header \"Authorization: Bearer ${API_TOKEN}\"\n\n# stdio（ローカルプロセス）\nclaude mcp add my-local -s project \\\n  -- npx -y @example/mcp-server\n\n# SSE（非推奨・レガシー）\nclaude mcp add my-sse -s project \\\n  --transport sse \\\n  --url https://mcp.example.com/sse",
              "recommended": true
            }
          ],
          "callouts": [
            {
              "type": "warning",
              "text": "SSE トランスポートは非推奨です。新規構築では HTTP トランスポートを使用してください。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "mcp-scopes",
          "title": "スコープの使い分け",
          "description": "local（デフォルト）・project（チーム共有・.mcp.json）・user（全プロジェクト共通）。優先度: local > project > user。",
          "content": "MCP サーバーの設定には 3 つのスコープがあります。\n\nlocal（デフォルト）: ~/.claude.json 内のプロジェクトパス配下に保存。そのマシンでそのプロジェクトを開いた場合のみ有効。\nproject: .mcp.json ファイルに保存。Git でチームと共有可能。\nuser: ~/.claude.json に保存。全プロジェクトで共通。\n\n優先度: local > project > user の順で、同名サーバーは上位が優先されます。",
          "code": [
            {
              "lang": "bash",
              "label": "--scope で指定する例",
              "value": "# local スコープ（デフォルト、省略可能）\nclaude mcp add my-server -s local -- npx @example/server\n\n# project スコープ（.mcp.json に保存、チーム共有可）\nclaude mcp add my-server -s project -- npx @example/server\n\n# user スコープ（全プロジェクト共通）\nclaude mcp add my-server -s user -- npx @example/server",
              "recommended": true
            }
          ],
          "callouts": [
            {
              "type": "tip",
              "text": "チームで共有するサーバーは -s project で .mcp.json に保存し、機密情報（API キー）は環境変数で渡して .mcp.json に直接書かないようにしましょう。"
            }
          ],
          "tags": ["上級者向け", "チーム向け"]
        },
        {
          "id": "mcp-json",
          "title": ".mcp.json の設定",
          "description": "プロジェクトスコープの設定ファイル。環境変数展開（${VAR:-default}）でセキュアに管理できる。",
          "content": ".mcp.json はプロジェクトルートに配置するチーム共有の MCP 設定ファイルです。mcpServers オブジェクトでサーバーを定義します。\n\n環境変数展開構文 ${VAR} または ${VAR:-デフォルト値} が使えます。展開可能な場所: command, args, env, url, headers フィールド。\n\n初回利用時に Claude Code は承認を求めます。claude mcp reset-project-choices でリセット可能です。",
          "code": [
            {
              "lang": "json",
              "label": ".mcp.json の例（環境変数展開）",
              "value": "{\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_TOKEN\": \"${GITHUB_TOKEN}\"\n      }\n    },\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\n        \"-y\",\n        \"@modelcontextprotocol/server-postgres\",\n        \"${DATABASE_URL:-postgresql://localhost:5432/dev}\"\n      ]\n    },\n    \"remote-api\": {\n      \"url\": \"${MCP_SERVER_URL}\",\n      \"headers\": {\n        \"Authorization\": \"Bearer ${API_TOKEN}\"\n      }\n    }\n  }\n}",
              "recommended": true
            }
          ],
          "callouts": [
            {
              "type": "important",
              "text": ".mcp.json を Git にコミットする場合は、API キー等の機密情報を直接書かず、必ず ${ENV_VAR} 形式で参照してください。"
            }
          ],
          "tags": ["上級者向け", "チーム向け"]
        },
        {
          "id": "mcp-manage",
          "title": "サーバーの管理",
          "description": "claude mcp list / get / remove コマンドと /mcp でセッション内のステータス確認・認証。",
          "content": "登録済み MCP サーバーの管理コマンド一覧です。セッション内では /mcp コマンドで接続状態の確認や OAuth 認証を行えます。\n\nlist_changed 通知に対応したサーバーは、ツール定義が動的に更新されます。追加した MCP ツールを claude mcp add-json で JSON 文字列として直接登録することもできます。",
          "code": [
            {
              "lang": "bash",
              "label": "MCP 管理コマンド一覧",
              "value": "# サーバー一覧表示\nclaude mcp list\n\n# サーバー詳細確認\nclaude mcp get <server-name>\n\n# サーバー削除\nclaude mcp remove <server-name>\n\n# JSON 文字列で直接追加\nclaude mcp add-json <name> '{\"command\":\"npx\",\"args\":[\"@example/server\"]}'\n\n# Claude Desktop からインポート\nclaude mcp add-from-claude-desktop\n\n# プロジェクト承認をリセット\nclaude mcp reset-project-choices"
            }
          ],
          "callouts": [
            {
              "type": "info",
              "text": "セッション内で /mcp と入力すると、接続中のサーバー一覧と各サーバーの状態を確認できます。OAuth 認証もここで行います。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "mcp-auth",
          "title": "OAuth 認証",
          "description": "OAuth 2.0 対応リモートサーバーへの認証。/mcp でブラウザ認証。Dynamic Client Registration 非対応サーバーは事前登録が必要。",
          "content": "OAuth 2.0 対応のリモート MCP サーバーには、/mcp コマンドでブラウザ認証フローを開始できます。トークンはキーチェーンに安全に保管され、自動でリフレッシュされます。\n\nDynamic Client Registration に対応していないサーバーの場合は、事前にクライアント ID とシークレットを取得して --client-id、--client-secret、--callback-port フラグで指定します。",
          "code": [
            {
              "lang": "bash",
              "label": "事前登録型 OAuth の設定",
              "value": "# Dynamic Client Registration 非対応サーバーの場合\nclaude mcp add my-oauth-server \\\n  --transport http \\\n  --url https://mcp.example.com \\\n  --client-id your-client-id \\\n  --client-secret your-client-secret \\\n  --callback-port 3000\n\n# 認証フロー開始（セッション内）\n> /mcp"
            }
          ],
          "callouts": [
            {
              "type": "info",
              "text": "認証トークンは OS のキーチェーンに安全に保管されます。有効期限が切れると自動でリフレッシュされます。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "mcp-toolsearch",
          "title": "Tool Search",
          "description": "MCP ツールが多い場合の自動最適化。ツール定義がコンテキストの 10% を超えると自動有効化。ENABLE_TOOL_SEARCH で制御。",
          "content": "MCP ツールが多数登録されている場合、Tool Search 機能が自動で有効化されます。ツール定義がコンテキストの 10% を超えると起動し、関連するツールのみを動的に検索・ロードします。\n\nENABLE_TOOL_SEARCH 環境変数で制御できます: auto（デフォルト）、auto:N（N トークン超で有効化）、true（常に有効）、false（無効）。\n\nMCP サーバー開発者向け: server instructions を詳細に記述すると Tool Search の精度が向上します。",
          "code": [
            {
              "lang": "bash",
              "label": "Tool Search の制御",
              "value": "# auto モード（デフォルト）: 10% 超で自動有効化\nexport ENABLE_TOOL_SEARCH=auto\n\n# 50000 トークン超で有効化\nexport ENABLE_TOOL_SEARCH=auto:50000\n\n# 常に有効\nexport ENABLE_TOOL_SEARCH=true\n\n# 無効化（全ツールを常にロード）\nexport ENABLE_TOOL_SEARCH=false"
            }
          ],
          "callouts": [
            {
              "type": "tip",
              "text": "特定のサーバーで Tool Search を無効にしたい場合は、disallowedTools に MCPSearch を追加してください。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "mcp-serve",
          "title": "Claude Code を MCP サーバーとして使う",
          "description": "claude mcp serve で Claude Code 自身を MCP サーバーとして起動。他アプリから Read / Edit / Glob 等を利用できる。",
          "content": "claude mcp serve コマンドで、Claude Code 自身を MCP サーバーとして起動できます。他のアプリケーション（Claude Desktop など）から Claude Code のビルトインツール（Read、Edit、Glob、Grep など）を利用できるようになります。\n\n実行パスの注意: claude コマンドのフルパスを which claude で確認して指定することを推奨します。",
          "code": [
            {
              "lang": "json",
              "label": "claude_desktop_config.json の設定例",
              "value": "{\n  \"mcpServers\": {\n    \"claude-code\": {\n      \"command\": \"/usr/local/bin/claude\",\n      \"args\": [\"mcp\", \"serve\"],\n      \"env\": {\n        \"ANTHROPIC_API_KEY\": \"${ANTHROPIC_API_KEY}\"\n      }\n    }\n  }\n}",
              "recommended": true
            },
            {
              "lang": "bash",
              "label": "claude コマンドのパス確認",
              "value": "# フルパスを確認してから設定に使用\nwhich claude\n# => /usr/local/bin/claude"
            }
          ],
          "callouts": [
            {
              "type": "info",
              "text": "claude mcp serve で提供されるツールは Read, Write, Edit, Glob, Grep, Bash 等です。Claude Desktop から直接ファイル操作が可能になります。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "mcp-managed",
          "title": "エンタープライズ管理",
          "description": "managed-mcp.json による排他制御と allowedMcpServers / deniedMcpServers ポリシー。denylist が最優先。",
          "content": "エンタープライズ環境では 2 つの方法で MCP サーバーを一元管理できます。\n\n方式 1 - managed-mcp.json: 管理者が配置したファイルが排他的に使用されます。ユーザーは独自サーバーを追加できません。\n\n方式 2 - ポリシー制御: allowedMcpServers（許可リスト）と deniedMcpServers（禁止リスト）で細かく制御。denylist が最優先です。",
          "code": [
            {
              "lang": "text",
              "label": "managed-mcp.json の配置場所",
              "value": "# macOS\n/Library/Application Support/ClaudeCode/managed-mcp.json\n\n# Linux\n/etc/claude-code/managed-mcp.json"
            },
            {
              "lang": "json",
              "label": "ポリシー制御の設定例（managed-settings.json）",
              "value": "{\n  \"allowedMcpServers\": [\n    {\n      \"serverName\": \"company-github\",\n      \"serverCommand\": \"npx @company/github-mcp-server\"\n    }\n  ],\n  \"deniedMcpServers\": [\n    {\n      \"serverUrl\": \"https://untrusted.example.com\"\n    }\n  ]\n}"
            }
          ],
          "callouts": [
            {
              "type": "important",
              "text": "deniedMcpServers は allowedMcpServers より優先されます。セキュリティポリシーとして明示的に禁止するサーバーは denylist に追加してください。"
            }
          ],
          "tags": ["上級者向け", "チーム向け"]
        },
        {
          "id": "mcp-bestpractices",
          "title": "ベストプラクティス",
          "description": "MCP_TIMEOUT・MAX_MCP_OUTPUT_TOKENS による調整。--mcp-debug でデバッグ。Windows では cmd /c ラッパーが必要。",
          "content": "MCP を安定して運用するためのベストプラクティスをまとめます。\n\nタイムアウト: MCP_TIMEOUT 環境変数でサーバー起動のタイムアウトを設定（デフォルト: 10 秒）。\n出力制限: MAX_MCP_OUTPUT_TOKENS でツール出力の最大トークン数を制限（デフォルト: 25000）。\nセキュリティ: サードパーティ MCP サーバーはプロンプトインジェクションのリスクがあります。信頼できるソースのみ使用してください。\nWindows: stdio サーバーは cmd /c ラッパーが必要な場合があります。",
          "code": [
            {
              "lang": "bash",
              "label": "デバッグと環境変数設定",
              "value": "# デバッグモードで起動\nclaude --mcp-debug\n\n# タイムアウト設定（ミリ秒）\nexport MCP_TIMEOUT=30000\n\n# 出力トークン制限\nexport MAX_MCP_OUTPUT_TOKENS=50000\n\n# Windows での stdio サーバー設定例\n# \"command\": \"cmd\"\n# \"args\": [\"/c\", \"npx\", \"-y\", \"@example/mcp-server\"]"
            }
          ],
          "callouts": [
            {
              "type": "warning",
              "text": "サードパーティの MCP サーバーはプロンプトインジェクション攻撃のベクターになり得ます。ツール説明が異常に長い・Claude に特定の行動を強制しようとする場合は注意してください。"
            }
          ],
          "tags": ["上級者向け"]
        }
      ]
    },
    {
      "id": "hooks",
      "name": "フック",
      "description": "ライフサイクルイベントにカスタム処理を挿入してワークフローを自動化する",
      "items": [
        {
          "id": "hooks-overview",
          "title": "フックとは",
          "description": "ツール実行前後・セッション開始終了等 14 種のイベントにカスタム処理を挿入。command / prompt / agent の 3 タイプ。",
          "content": "フックは Claude Code のライフサイクルイベントにカスタム処理を挿入する機能です。3 つのタイプがあります:\n\n- command: シェルコマンドを実行（最も一般的）\n- prompt: LLM に yes/no 判定を委任\n- agent: サブエージェントで検証\n\n主な活用場面:\n- ファイル保存のたびに prettier / ESLint を自動実行\n- 危険なコマンド（rm -rf など）を実行前にブロック\n- タスク完了時に OS 通知・Slack 通知を送る\n- セッション開始時にコンテキストを注入",
          "code": [
            {
              "lang": "text",
              "label": "利用可能な 14 種のフックイベント",
              "value": "# ツール系\nPreToolUse         # ツール実行直前（ブロック可能）\nPostToolUse        # ツール実行直後\nPostToolUseFailure # ツール実行失敗後\nPermissionRequest  # 権限確認時（ブロック可能）\n\n# セッション系\nSessionStart       # セッション開始時\nSessionEnd         # セッション終了時\nUserPromptSubmit   # ユーザー入力送信時（ブロック可能）\nStop               # Claude が応答完了時（ブロック可能）\n\n# エージェント系\nSubagentStart      # サブエージェント開始時\nSubagentStop       # サブエージェント終了時\nTeammateIdle       # チームメート待機状態\nTaskCompleted      # タスク完了時\n\n# 通知系\nNotification       # Claude から通知があった時"
            }
          ],
          "callouts": [
            {
              "type": "info",
              "text": "フックは .claude/settings.json（プロジェクトスコープ）または ~/.claude/settings.json（ユーザースコープ）で設定します。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "hooks-config",
          "title": "設定ファイルと構成",
          "description": "3 層のネスト構造（イベント → マッチャーグループ → ハンドラー）。6 種の設定場所でスコープを使い分け。",
          "content": "フックの設定は 3 層のネスト構造になっています:\n1. イベント名（PreToolUse, PostToolUse 等）\n2. マッチャーグループ（どのツールに発火するか）\n3. ハンドラー（実行するコマンド等）\n\n設定可能な 6 つの場所（スコープ）:\n- ~/.claude/settings.json（ユーザーグローバル）\n- .claude/settings.json（プロジェクト共有）\n- .claude/settings.local.json（プロジェクトローカル、非共有）\n- 管理ポリシー\n- Plugin hooks/hooks.json\n- スキル・エージェントのフロントマター",
          "code": [
            {
              "lang": "json",
              "label": ".claude/settings.json の基本構造",
              "value": "{\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Bash\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"echo 'Bash 実行前'\",\n            \"timeout\": 10\n          }\n        ]\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"npx prettier --write $CLAUDE_FILE_PATH\"\n          }\n        ]\n      }\n    ]\n  }\n}",
              "recommended": true
            }
          ],
          "callouts": [
            {
              "type": "tip",
              "text": "プロジェクト固有でチームに共有しないフックは .claude/settings.local.json（.gitignore に追加済み）に書くと安全です。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "hooks-matchers",
          "title": "マッチャーパターン",
          "description": "正規表現でツール名をマッチ。MCP ツールは mcp__server__tool パターン。\"*\" / \"\" / 省略で全マッチ。",
          "content": "matcher フィールドでどのツール・イベントに発火するかを正規表現で指定します。\n\n基本パターン:\n- 単一ツール: \"Bash\"\n- 複数ツール（OR）: \"Edit|Write\"\n- 全ツール: \"*\" または \"\" または省略\n- MCP ツール: \"mcp__server__tool\" または \"mcp__.*\"\n\nPreToolUse のマッチ対象: Bash, Edit, Write, Read, Glob, Grep, Task, WebFetch, WebSearch + MCP ツール",
          "code": [
            {
              "lang": "json",
              "label": "マッチャーパターンの例",
              "value": "{\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Bash\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"./check-bash.sh\" }]\n      },\n      {\n        \"matcher\": \"Edit|Write\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"./validate-file.sh\" }]\n      },\n      {\n        \"matcher\": \"mcp__github__.*\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"./log-mcp-github.sh\" }]\n      },\n      {\n        \"matcher\": \"\",\n        \"hooks\": [{ \"type\": \"command\", \"command\": \"./log-all-tools.sh\" }]\n      }\n    ]\n  }\n}"
            }
          ],
          "callouts": [
            {
              "type": "info",
              "text": "MCP ツール名のパターンは mcp__サーバー名__ツール名 です。例: mcp__github__create_issue"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "hooks-command",
          "title": "コマンド型フック",
          "description": "type: command でシェルコマンドを実行。stdin で JSON 入力を受信。$CLAUDE_PROJECT_DIR 等のパス変数が使える。",
          "content": "最も一般的なフックタイプです。type: \"command\" でシェルコマンドを実行します。\n\n共通フィールド:\n- type: \"command\"（必須）\n- command: 実行するコマンド\n- timeout: タイムアウト秒数\n- statusMessage: Claude に表示するメッセージ\n- once: true で 1 セッションに 1 回のみ実行\n- async: true でバックグラウンド実行\n\nフックは stdin から JSON 形式のイベントデータを受け取ります。環境変数 $CLAUDE_PROJECT_DIR、${CLAUDE_PLUGIN_ROOT} 等でパスを参照できます。",
          "code": [
            {
              "lang": "json",
              "label": "ファイル変更後に自動 lint",
              "value": "{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"cd $CLAUDE_PROJECT_DIR && npx eslint --fix $CLAUDE_FILE_PATH 2>&1\",\n            \"timeout\": 30,\n            \"statusMessage\": \"ESLint を実行中...\"\n          }\n        ]\n      }\n    ]\n  }\n}",
              "recommended": true
            }
          ],
          "callouts": [
            {
              "type": "info",
              "text": "$CLAUDE_FILE_PATH は編集されたファイルのパス、$CLAUDE_PROJECT_DIR はプロジェクトルートのパスです。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "hooks-exitcodes",
          "title": "終了コードと出力制御",
          "description": "exit 0: 成功。exit 2: ブロック（stderr が Claude へのフィードバック）。JSON で continue / stopReason / suppressOutput を制御。",
          "content": "フックの終了コードで Claude の動作を制御できます。\n\nexit 0: 成功。stdout の JSON を処理（continue, stopReason, systemMessage, suppressOutput）。\nexit 2: ブロック。stderr の内容が Claude またはユーザーへのフィードバックとして返されます。\nその他: 非ブロッキングエラー（警告として扱われる）。\n\nブロック可能なイベント: PreToolUse, PermissionRequest, UserPromptSubmit, Stop\nブロック不可能なイベント: PostToolUse, Notification, SessionStart, SessionEnd",
          "code": [
            {
              "lang": "bash",
              "label": "終了コードと JSON 出力の例",
              "value": "#!/bin/bash\n# PreToolUse フック: rm -rf をブロック\n\nINPUT=$(cat)  # stdin から JSON を読む\nCOMMAND=$(echo \"$INPUT\" | jq -r '.tool_input.command // \"\"')\n\nif echo \"$COMMAND\" | grep -qE 'rm\\s+-rf'; then\n  echo 'rm -rf は危険なため実行をブロックしました' >&2\n  exit 2  # ブロック\nfi\n\n# 追加コンテキストを Claude に提供（exit 0）\necho '{\"additionalContext\": \"コマンドは安全です\"}'\nexit 0",
              "recommended": true
            }
          ],
          "callouts": [
            {
              "type": "tip",
              "text": "exit 2 のメッセージは stderr に書いてください。stdout は JSON として解釈されます。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "hooks-pretooluse",
          "title": "PreToolUse の詳細",
          "description": "ツール実行直前に発火。permissionDecision で allow/deny/ask、updatedInput で入力を修正、additionalContext でコンテキスト注入。",
          "content": "PreToolUse は各ツール実行の直前に発火します。JSON 出力で細かい制御が可能です。\n\nhookSpecificOutput の決定制御:\n- permissionDecision: \"allow\"（許可）、\"deny\"（拒否）、\"ask\"（ユーザー確認）\n- permissionDecisionReason: 理由テキスト\n- updatedInput: ツールへの入力を上書き修正する\n- additionalContext: Claude へ追加コンテキストを注入\n\nstdin の JSON スキーマ:\n- tool_name: ツール名\n- tool_input: ツールへの入力（Bash なら command フィールド等）",
          "code": [
            {
              "lang": "bash",
              "label": "rm -rf をブロックする PreToolUse フック",
              "value": "#!/bin/bash\n# .claude/hooks/check-dangerous.sh\n\nINPUT=$(cat)\nTOOL=$(echo \"$INPUT\" | jq -r '.tool_name')\nCMD=$(echo \"$INPUT\" | jq -r '.tool_input.command // \"\"')\n\nif [ \"$TOOL\" = \"Bash\" ] && echo \"$CMD\" | grep -qE 'rm\\s+-rf\\s+/'  ; then\n  echo '/ ルートへの rm -rf は禁止されています' >&2\n  exit 2\nfi\n\nexit 0",
              "recommended": true
            },
            {
              "lang": "json",
              "label": "updatedInput でコマンドを修正する例（JSON 出力）",
              "value": "{\n  \"hookSpecificOutput\": {\n    \"permissionDecision\": \"allow\",\n    \"updatedInput\": {\n      \"command\": \"ls -la --color=auto\"\n    },\n    \"additionalContext\": \"ls コマンドに --color=auto を追加しました\"\n  }\n}"
            }
          ],
          "callouts": [
            {
              "type": "warning",
              "text": "updatedInput を使う場合は、ツールの入力スキーマに準拠した形式で指定してください。不正な入力はエラーになります。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "hooks-posttooluse",
          "title": "PostToolUse の詳細",
          "description": "ツール成功後に発火。tool_input + tool_response を受信。decision: block でフィードバック。MCP 出力の差し替えも可能。",
          "content": "PostToolUse はツールが成功した後に発火します。tool_input（ツールへの入力）と tool_response（ツールの出力）の両方を受信できます。\n\ndecision: \"block\" を JSON 出力に含めると、Claude にフィードバックを返しつつ次の処理をブロックできます。\n\nPostToolUseFailure はツールがエラーになった時に発火します。error フィールドでエラー内容を取得できます。\n\nudpatedMCPToolOutput: MCP ツールの出力を差し替えることができます（MCP ツールの PostToolUse のみ）。",
          "code": [
            {
              "lang": "bash",
              "label": "ファイル編集後の自動フォーマット",
              "value": "#!/bin/bash\n# PostToolUse: Write/Edit 後に prettier を実行\n\nINPUT=$(cat)\nTOOL=$(echo \"$INPUT\" | jq -r '.tool_name')\nFILE=$(echo \"$INPUT\" | jq -r '.tool_input.file_path // .tool_input.path // \"\"')\n\nif [ \"$TOOL\" = \"Write\" ] || [ \"$TOOL\" = \"Edit\" ]; then\n  if [ -n \"$FILE\" ] && [[ \"$FILE\" =~ \\.(ts|tsx|js|jsx|json|css|md)$ ]]; then\n    npx prettier --write \"$FILE\" 2>/dev/null\n  fi\nfi\n\nexit 0"
            }
          ],
          "callouts": [
            {
              "type": "info",
              "text": "PostToolUse は exit 2 でもブロック可能ですが、ツールはすでに実行済みです。フィードバックとして使い、ツール自体をブロックしたい場合は PreToolUse を使ってください。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "hooks-session",
          "title": "セッション系イベント",
          "description": "SessionStart で初期コンテキスト注入。UserPromptSubmit でユーザー入力をブロック・加工。SessionEnd でクリーンアップ。",
          "content": "セッションのライフサイクルに対応するイベントです。\n\nSessionStart: セッション開始時に発火。source フィールドで起動方法（startup/resume/clear/compact）を確認できます。additionalContext で初期コンテキストを注入可能。CLAUDE_ENV_FILE 環境変数で環境変数ファイルを指定して永続化できます。\n\nUserPromptSubmit: ユーザーがメッセージを送信した時に発火。ブロック可能。prompt フィールドで入力内容を確認できます。\n\nSessionEnd: セッション終了時に発火。reason フィールドで終了理由（clear/logout/prompt_input_exit/other）を確認できます。クリーンアップ処理に使います。",
          "code": [
            {
              "lang": "bash",
              "label": "SessionStart でコンテキストを注入",
              "value": "#!/bin/bash\n# SessionStart フック: 環境情報を自動注入\n\nDATE=$(date '+%Y-%m-%d %H:%M')\nBRANCH=$(git branch --show-current 2>/dev/null || echo 'N/A')\nGIT_STATUS=$(git status --short 2>/dev/null | head -5 || echo '')\n\necho \"{\n  \\\"additionalContext\\\": \\\"現在の日時: $DATE\\\\nブランチ: $BRANCH\\\\n変更ファイル:\\\\n$GIT_STATUS\\\"\n}\"\nexit 0"
            }
          ],
          "callouts": [
            {
              "type": "tip",
              "text": "CLAUDE_ENV_FILE=/path/to/.env を SessionStart フックで設定すると、環境変数をセッション全体で永続化できます。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "hooks-agent-events",
          "title": "エージェント系イベント",
          "description": "SubagentStart / SubagentStop / TeammateIdle / TaskCompleted でマルチエージェント実行を制御。",
          "content": "マルチエージェント環境でのライフサイクルを制御するイベントです。\n\nSubagentStart: サブエージェント開始時。agent_id, agent_type を受信。additionalContext でコンテキスト注入可能。\n\nSubagentStop: サブエージェント終了時。agent_transcript_path でトランスクリプトを取得できます。\n\nTeammateIdle: チームメートが待機状態になった時。exit 2 で追加作業の指示を返せます。\n\nTaskCompleted: タスクが完了した時。task_id, task_subject を受信。exit 2 でタスク完了をブロックできます。",
          "code": [
            {
              "lang": "bash",
              "label": "SubagentStop でトランスクリプトをログ保存",
              "value": "#!/bin/bash\n# SubagentStop: サブエージェントのトランスクリプトを保存\n\nINPUT=$(cat)\nAGENT_ID=$(echo \"$INPUT\" | jq -r '.agent_id')\nTRANSCRIPT=$(echo \"$INPUT\" | jq -r '.agent_transcript_path // \"\"')\n\nif [ -n \"$TRANSCRIPT\" ] && [ -f \"$TRANSCRIPT\" ]; then\n  mkdir -p .claude/logs\n  cp \"$TRANSCRIPT\" \".claude/logs/agent-${AGENT_ID}.jsonl\"\nfi\n\nexit 0"
            }
          ],
          "callouts": [
            {
              "type": "info",
              "text": "TeammateIdle フックで exit 2 を返すと、チームメートへのメッセージとして stderr の内容が送信されます。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "hooks-prompt-agent",
          "title": "プロンプト型・エージェント型フック",
          "description": "prompt 型は LLM に yes/no を委任。agent 型は Read/Grep/Glob 等のツールで検証（最大 50 ターン）。Stop フックでのタスク検証に最適。",
          "content": "command 以外のフックタイプです。\n\nprompt 型: type: \"prompt\" でLLM が yes/no の判定を行います。$ARGUMENTS でイベント入力を注入し、LLM のレスポンス（{ok: true/false, reason}）で決定します。\n\nagent 型: type: \"agent\" でサブエージェントが Read、Grep、Glob 等のツールを使って検証します。最大 50 ターンまで実行可能。Stop フックで「全タスクが完了しているか確認してから停止する」という使い方に最適です。",
          "code": [
            {
              "lang": "json",
              "label": "Stop フックでタスク完了を確認（agent 型）",
              "value": "{\n  \"hooks\": {\n    \"Stop\": [\n      {\n        \"matcher\": \"\",\n        \"hooks\": [\n          {\n            \"type\": \"agent\",\n            \"command\": \"TodoRead ツールで未完了タスクを確認し、全て完了していれば停止を許可してください。未完了のタスクがあれば、それを完了させてから停止してください。\"\n          }\n        ]\n      }\n    ]\n  }\n}"
            }
          ],
          "callouts": [
            {
              "type": "warning",
              "text": "agent 型フックは Stop フックで使う場合、stop_hook_active のチェックを入れて無限ループを防いでください（後述のベストプラクティス参照）。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "hooks-async",
          "title": "非同期フック",
          "description": "async: true でバックグラウンド実行。Claude をブロックせず次の処理へ進む。systemMessage / additionalContext は次ターンで配信。",
          "content": "async: true を設定すると、フックがバックグラウンドで実行されます。Claude は結果を待たずに次の処理に進めます。\n\n主な使用場面: テストスイートの実行、外部サービスへの通知、ログ記録など、時間がかかるが結果を即座に必要としない処理。\n\n制約:\n- command 型のみ対応\n- 決定制御（permissionDecision 等）は不可\n- 重複排除なし（同時に複数起動される可能性あり）\n- systemMessage/additionalContext は次のターンで配信される",
          "code": [
            {
              "lang": "json",
              "label": "ファイル変更後にテストを非同期実行",
              "value": "{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"async\": true,\n            \"command\": \"cd $CLAUDE_PROJECT_DIR && pnpm test --passWithNoTests 2>&1 | tail -20 > .claude/last-test-result.txt\"\n          }\n        ]\n      }\n    ]\n  }\n}",
              "recommended": true
            }
          ],
          "callouts": [
            {
              "type": "info",
              "text": "非同期フックは Claude の応答速度に影響しません。長時間かかる処理（ビルド、テストスイート全体）に適しています。"
            }
          ],
          "tags": ["上級者向け"]
        },
        {
          "id": "hooks-bestpractices",
          "title": "ベストプラクティス",
          "description": "入力バリデーション必須。変数はクォート。Stop フックの無限ループは stop_hook_active で防止。claude --debug でデバッグ。",
          "content": "フックを安全・安定して運用するためのベストプラクティスです。\n\nセキュリティ:\n- ユーザー入力を直接コマンドに渡さない（インジェクション対策）\n- 変数は必ずダブルクォートで囲む（\"$VAR\"）\n- パストラバーサルを防ぐため、ファイルパスを検証する\n- 機密ファイル（.env, 秘密鍵）へのアクセスを避ける\n\nStop フックの無限ループ防止:\n- $CLAUDE_STOP_HOOK_ACTIVE 環境変数を確認して、Stop フック自体が Stop を再トリガーしないようにする\n\nデバッグ:\n- claude --debug でフックの実行ログを確認\n- Ctrl+O で verbose モードに切り替え",
          "code": [
            {
              "lang": "bash",
              "label": "Stop フックの無限ループ防止",
              "value": "#!/bin/bash\n# Stop フック: stop_hook_active をチェックして無限ループを防止\n\nif [ \"${CLAUDE_STOP_HOOK_ACTIVE}\" = \"true\" ]; then\n  # Stop フック自体から呼び出されている場合はスキップ\n  exit 0\nfi\n\n# 通常の Stop 処理\nINPUT=$(cat)\n# ... 処理 ...\n\nexit 0",
              "recommended": true
            },
            {
              "lang": "bash",
              "label": "全フック無効化（デバッグ用）",
              "value": "# 設定ファイルで全フックを無効化\n# .claude/settings.json\n{\n  \"disableAllHooks\": true\n}"
            }
          ],
          "callouts": [
            {
              "type": "important",
              "text": "セッション中に設定ファイルを変更してもフックは即時反映されません。セキュリティ設計上、変更は次のセッションから有効です。"
            }
          ],
          "tags": ["上級者向け"]
        }
      ]
    }
  ]
}
